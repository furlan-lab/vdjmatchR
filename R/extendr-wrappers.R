# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_vdjmatchR_wrappers", use_symbols = TRUE, package_name = "vdjmatchR")

#' @docType package
#' @usage NULL
#' @useDynLib vdjmatchR, .registration = TRUE
NULL

#' Match a single clonotype against the database.
#' Returns a list of columns (vector-of-equal-length) suitable for as.data.frame in R.
match_tcr <- function(db, cdr3, v_segment, j_segment, scope, top_n) .Call(wrap__match_tcr, db, cdr3, v_segment, j_segment, scope, top_n)

#' Batch match: vectors of cdr3/v/j; returns stacked results with query metadata.
match_tcr_many <- function(db, cdr3, v_segment, j_segment, scope, top_n) .Call(wrap__match_tcr_many, db, cdr3, v_segment, j_segment, scope, top_n)

#' Ensure VDJdb exists locally and return the path.
vdjdb_ensure <- function(use_fat_db) .Call(wrap__vdjdb_ensure, use_fat_db)

#' Download/update the VDJdb files (slim and fat).
vdjdb_update <- function() .Call(wrap__vdjdb_update)

RDatabase <- new.env(parent = emptyenv())

RDatabase$new_from_file <- function(path) .Call(wrap__RDatabase__new_from_file, path)

RDatabase$new_from_vdjdb <- function(use_fat_db) .Call(wrap__RDatabase__new_from_vdjdb, use_fat_db)

RDatabase$len <- function() .Call(wrap__RDatabase__len, self)

RDatabase$filter <- function(species, gene, min_vdjdb_score) .Call(wrap__RDatabase__filter, self, species, gene, min_vdjdb_score)

RDatabase$filter_by_epitope_size <- function(min_size) .Call(wrap__RDatabase__filter_by_epitope_size, self, min_size)

#' @export
`$.RDatabase` <- function (self, name) { func <- RDatabase[[name]]; environment(func) <- environment(); func }

#' @export
`[[.RDatabase` <- `$.RDatabase`


# nolint end
