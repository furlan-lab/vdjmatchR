---
title: "TCR Motif Analysis and Visualization"
author: "vdjmatchR Authors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TCR Motif Analysis and Visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", eval = T)
```

## Installation

### Prerequisites

- R (>= 4.0)
- Rust (>= 1.70) - [Install Rust](https://www.rust-lang.org/tools/install)
- R development tools (Rtools on Windows, Xcode Command Line Tools on macOS)

### From Github in R

```{r, eval = F}
devtools::install_github("furlan-lab/vdjmatchR")
```

### Clone and install (from source) in shell

```{sh, eval = F}
git clone https://github.com/furlan-lab/vdjmatchR.git
cd vdjmatchR
R CMD INSTALL .
```

### Install motifStack from Bioconductor

```{r, eval = F}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("motifStack")
BiocManager::install("Biostrings")
```

## Overview

This vignette demonstrates how to create sequence motif logos from TCR CDR3 sequences
using the motifStack package. Motif logos visualize conserved amino acid patterns
within groups of TCRs, such as those recognizing the same epitope.

**Key applications:**

- Visualize conserved positions in epitope-specific TCRs
- Compare motifs across different epitopes
- Identify shared patterns in viral-reactive TCR repertoires
- Analyze motifs in your matched TCR data

## Load packages

```{r packages}
library(vdjmatchR)
library(data.table)
library(motifStack)
library(Biostrings)
library(ggplot2)
```

## Load and prepare VDJdb data

```{r load-db}
# Load the full VDJdb database
db_path <- vdjdb_packaged_path(use_fat_db = TRUE)
db <- vdjdb_open_file(db_path)

# Filter for human TRB sequences with high confidence
db_filtered <- filter_db(db,
                         species = "HomoSapiens",
                         gene = "TRB",
                         min_vdjdb_score = 2)

# Convert to data.table for exploration
dt <- db_to_table(db_filtered)
```

## Identify epitopes with sufficient TCR sequences

For meaningful motif analysis, we need epitopes with multiple TCR sequences:

```{r epitope-counts}
# Count TCRs per epitope
epitope_counts <- dt[, .N, by = .(antigen_epitope, antigen_species)][order(-N)]
head(epitope_counts, 20)

# Filter epitopes with at least 10 unique CDR3 sequences
epitopes_sufficient <- epitope_counts[N >= 10]
cat(sprintf("Found %d epitopes with >=10 TCR sequences\n", nrow(epitopes_sufficient)))
```

## Helper function: Create motif from CDR3 sequences

```{r helper-functions}
# Function to create position frequency matrix from aligned CDR3 sequences
create_tcr_motif <- function(cdr3_sequences, name = "TCR_motif") {

  # Remove any NA or empty sequences
  cdr3_sequences <- cdr3_sequences[!is.na(cdr3_sequences) & nzchar(cdr3_sequences)]

  if (length(cdr3_sequences) < 5) {
    stop("Need at least 5 sequences to create a meaningful motif")
  }

  # Get sequence lengths
  seq_lengths <- nchar(cdr3_sequences)

  # Strategy: align by center or use most common length
  median_length <- median(seq_lengths)

  # Filter sequences close to median length (within 2 amino acids)
  keep <- abs(seq_lengths - median_length) <= 2
  filtered_seqs <- cdr3_sequences[keep]

  if (length(filtered_seqs) < 5) {
    warning("Too few sequences after length filtering, using all sequences")
    filtered_seqs <- cdr3_sequences
  }

  # Pad sequences to same length (center alignment)
  max_len <- max(nchar(filtered_seqs))

  aligned_seqs <- sapply(filtered_seqs, function(seq) {
    len <- nchar(seq)
    if (len < max_len) {
      pad_total <- max_len - len
      pad_left <- floor(pad_total / 2)
      pad_right <- pad_total - pad_left
      seq <- paste0(paste(rep("-", pad_left), collapse = ""),
                   seq,
                   paste(rep("-", pad_right), collapse = ""))
    }
    seq
  })

  # Create AAStringSet
  aa_set <- AAStringSet(aligned_seqs)

  # Create position frequency matrix with probabilities
  pfm <- consensusMatrix(aa_set, as.prob = TRUE)

  # Remove gap row if present
  if ("-" %in% rownames(pfm)) {
    pfm <- pfm[rownames(pfm) != "-", , drop = FALSE]
    # Renormalize after removing gaps
    pfm <- sweep(pfm, 2, colSums(pfm), "/")
  }

  # Ensure columns sum to 1.0 (handle any rounding errors)
  pfm <- sweep(pfm, 2, colSums(pfm), "/")

  # Replace any NaN with 0
  pfm[is.nan(pfm)] <- 0

  # Convert to pfm object for motifStack
  pfm_obj <- new("pfm", mat = pfm, name = name, color = colorset(alphabet = "AA", colorScheme = "chemistry"))

  return(pfm_obj)
}

# Function to create motif for a specific epitope
create_epitope_motif <- function(dt, epitope_name, antigen_species = NULL) {
  if (!is.null(antigen_species)) {
    seqs <- dt[antigen_epitope == epitope_name & antigen_species == antigen_species, cdr3]
    motif_name <- paste0(epitope_name, " (", antigen_species, ")")
  } else {
    seqs <- dt[antigen_epitope == epitope_name, cdr3]
    motif_name <- epitope_name
  }

  create_tcr_motif(unique(seqs), name = motif_name)
}
```

## Example 1: Single epitope motif logo

Let's create a motif logo for a well-studied CMV epitope:

```{r single-motif}
# CMV pp65 epitope NLVPMVATV - one of the most studied
cmv_pp65 <- dt[antigen_epitope == "NLVPMVATV" & antigen_species == "CMV"]
cat(sprintf("Found %d unique CDR3 sequences for CMV NLVPMVATV\n",
            length(unique(cmv_pp65$cdr3))))

# Create motif
cmv_motif <- create_epitope_motif(dt, "NLVPMVATV", "CMV")

# Plot motif logo
plotMotifLogo(cmv_motif,
              font = "helvetica",
              ic.scale = TRUE,
              motifName = "CMV pp65 NLVPMVATV-specific TCR CDR3 Motif")
```

## Example 2: Compare motifs across epitopes

Compare TCR motifs for different CMV epitopes:

```{r compare-cmv}
# Get top CMV epitopes
cmv_epitopes <- dt[antigen_species == "CMV", .N, by = antigen_epitope][order(-N)][1:5]

# Create motifs for top CMV epitopes with sufficient sequences
cmv_motif_list <- list()
for (i in 1:nrow(cmv_epitopes)) {
  epi <- cmv_epitopes$antigen_epitope[i]
  n <- cmv_epitopes$N[i]

  if (n >= 10) {
    tryCatch({
      motif <- create_epitope_motif(dt, epi, "CMV")
      cmv_motif_list[[epi]] <- motif
    }, error = function(e) {
      message(sprintf("Could not create motif for %s: %s", epi, e$message))
    })
  }
}

# Plot motifs side by side
if (length(cmv_motif_list) > 0) {
  plotMotifLogoStack(cmv_motif_list,
                     font = "helvetica",
                     ic.scale = TRUE)
}
```

## Example 3: Compare across viral species

Compare TCR motifs for epitopes from different viruses:

```{r viral-comparison}
# Select well-represented epitopes from different viruses
viral_epitopes <- data.frame(
  epitope = c("NLVPMVATV", "GLCTLVAML", "GILGFVFTL"),
  species = c("CMV", "EBV", "InfluenzaA"),
  stringsAsFactors = FALSE
)

viral_motifs <- list()
for (i in 1:nrow(viral_epitopes)) {
  epi <- viral_epitopes$epitope[i]
  sp <- viral_epitopes$species[i]

  n <- dt[antigen_epitope == epi & antigen_species == sp, .N]

  if (n >= 10) {
    tryCatch({
      motif <- create_epitope_motif(dt, epi, sp)
      viral_motifs[[paste(sp, epi, sep = "_")]] <- motif
    }, error = function(e) {
      message(sprintf("Could not create motif for %s %s: %s", sp, epi, e$message))
    })
  }
}

# Plot comparison
if (length(viral_motifs) > 0) {
  plotMotifLogoStack(viral_motifs,
                     font = "helvetica",
                     ic.scale = TRUE)
}
```

## Example 4: Analyze motifs in your matched data

After matching your TCRs to VDJdb, analyze motifs in your hits:

```{r user-data, eval = FALSE}
# Assuming you have matched TCRs from Seurat object
# (see Seurat integration vignette for details)

# Example: you have a data.frame 'hits' with matched TCRs
# hits <- match_tcr_many_df(db_filtered, query_cdr3s, query_vs, query_js, ...)

# Group by epitope and create motifs for abundant hits
epitope_hits <- hits[, .N, by = antigen_epitope][order(-N)]

# Create motif for your most common epitope hit
top_epitope <- epitope_hits$antigen_epitope[1]
my_tcrs <- hits[antigen_epitope == top_epitope, query_cdr3]

if (length(unique(my_tcrs)) >= 5) {
  my_motif <- create_tcr_motif(unique(my_tcrs),
                               name = paste("My data:", top_epitope))

  # Compare to VDJdb reference for same epitope
  ref_motif <- create_epitope_motif(dt, top_epitope)

  # Plot comparison
  plotMotifLogoStack(list(my_motif, ref_motif),
                     font = "helvetica",
                     ic.scale = TRUE,
                     motifName = sprintf("Your TCRs vs VDJdb Reference: %s", top_epitope))
}
```

## Example 5: CDR3 length distribution by epitope

Before creating motifs, visualize CDR3 length distributions:

```{r length-dist}
# Add CDR3 length column
dt[, cdr3_length := nchar(cdr3)]

# Get top epitopes
top_epitopes <- dt[, .N, by = antigen_epitope][order(-N)][1:10, antigen_epitope]

# Plot length distribution for top epitopes
ggplot(dt[antigen_epitope %in% top_epitopes],
       aes(x = cdr3_length, fill = antigen_epitope)) +
  geom_histogram(binwidth = 1, alpha = 0.7, position = "identity") +
  facet_wrap(~antigen_epitope, ncol = 2) +
  labs(title = "CDR3 Length Distribution by Epitope",
       x = "CDR3 Length (amino acids)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "none")
```

## Advanced: Information content analysis

Analyze position-specific information content:

```{r ic-analysis}
# Function to calculate information content per position
calculate_ic <- function(pfm_obj) {
  # Extract probability matrix from pfm object
  prob_matrix <- pfm_obj@mat

  # Calculate Shannon entropy per position
  # Background frequency for amino acids (uniform)
  n_aa <- nrow(prob_matrix)
  max_entropy <- log2(n_aa)

  ic_per_pos <- apply(prob_matrix, 2, function(col) {
    # Remove zeros to avoid log(0)
    col <- col[col > 0]
    entropy <- -sum(col * log2(col))
    information <- max_entropy - entropy
    return(information)
  })

  return(ic_per_pos)
}

# Create motif and extract IC for CMV epitope
cmv_motif <- create_epitope_motif(dt, "NLVPMVATV", "CMV")
ic_values <- calculate_ic(cmv_motif)

# Plot information content per position
ic_df <- data.frame(
  position = 1:length(ic_values),
  information_content = ic_values
)

ggplot(ic_df, aes(x = position, y = information_content)) +
  geom_line(color = "steelblue", size = 1) +
  geom_point(color = "steelblue", size = 2) +
  labs(title = "Information Content per CDR3 Position - CMV NLVPMVATV",
       x = "Position",
       y = "Information Content (bits)") +
  theme_minimal()
```

## Practical considerations

### Minimum sequence requirements

For reliable motif analysis:

- **Minimum 5 sequences**: Required for basic motif
- **10+ sequences**: Recommended for meaningful patterns
- **20+ sequences**: Better for robust motif identification
- **50+ sequences**: Ideal for detailed analysis

### Handling variable length CDR3s

TCR CDR3 sequences have variable length, which complicates alignment:

**Strategies used in this vignette:**

1. **Length filtering**: Keep sequences within ±2 amino acids of median
2. **Center alignment**: Pad sequences to align central positions
3. **Alternative**: Use tools like MUSCLE for multiple sequence alignment

### Epitope selection tips

Best epitopes for motif analysis:

- High sequence count (>10 unique CDR3s)
- Well-characterized (CMV, EBV, Influenza epitopes)
- High VDJdb confidence scores (≥2)
- Restricted by common HLA alleles

### Color schemes

motifStack supports different color schemes:

```{r color-schemes, eval = FALSE}
# Chemistry-based coloring (default for amino acids)
pfm <- new("pfm", mat = matrix, color = colorset(alphabet = "AA", colorScheme = "chemistry"))

# Hydrophobicity-based
pfm <- new("pfm", mat = matrix, color = colorset(alphabet = "AA", colorScheme = "hydrophobicity"))

# Custom colors
pfm <- new("pfm", mat = matrix, color = colorset(alphabet = "AA", colorScheme = "custom"))
```

## Interpretation guidelines

**High information content positions**: Indicate conserved amino acids important for epitope recognition

**Variable positions**: May represent:
- Degeneracy in TCR binding
- Sampling bias in VDJdb
- True diversity in recognition modes

**Central positions**: Often more conserved as they typically contact peptide-MHC

**Flanking positions**: May show more variation

## Session info

```{r session}
sessionInfo()
```
